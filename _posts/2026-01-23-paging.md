---
title: "Paging & Address Translation"
date: 2026-01-24 01:00:00 +0900
categories: [CS]
tags: [paging, mmu, tlb, memory-management]
math: true
---

## What is Paging?
---
페이징은 물리 메모리를 동일한 크기의 여러 페이지로 나누고, 나뉜 페이지들을 비연속적으로 할당하는 메모리 관리 기법이다. 여기서 비연속적이란 하나의 프로그램이 물리 메모리의 여러 부분에 흩어져 할당될 수 있음을 뜻한다.

물리 메모리가 동일한 크기의 페이지로 나뉘기 때문에 외부 단편화가 발생하지 않는다. 다만, 프로그램에 할당된 메모리가 항상 페이지 크기의 배수인 것은 아니므로 마지막 페이지의 일부가 낭비될 수 있다. 이를 내부 단편화라고 하며, 보통 페이지 크기의 절반 정도가 낭비된다고 본다.

외부 단편화는 메모리 할당 패턴에 따라 예측이 어렵지만, 내부 단편화는 페이지 크기에 따라 그 범위를 충분히 예측할 수 있어 관리가 용이하다는 장점이 있다.


## MMU (Memory Management Unit)
---
모든 프로세스는 독립적인 가상 주소 공간을 갖는다. 프로세스가 포인터로 접근하는 주소는 실제 물리 주소가 아니라 가상 주소이며, 프로세스는 이 공간을 0번지부터 차례대로 나열된 선형적인 형태로 인식하여 사용한다. 이 가상 주소는 커널에 의해 물리 메모리의 특정 위치에 매핑된다.

그러나 페이징은 비연속적인 메모리 할당 기법이므로, 프로세스가 바라보는 가상 주소 공간과 달리 실제 물리 메모리는 연속적으로 배치되지 않는다. 따라서 프로세스가 선형적으로 접근하는 가상 주소를 실제 데이터가 저장된 비연속적인 물리 주소로 변환하는 메커니즘이 필요하며, 이러한 주소 변환을 수행하는 전용 하드웨어를 MMU라고 한다.

## Address Translation Mechanism
---
가상 주소를 물리 주소로 변환하기 위해서는 두 주소의 매핑 정보가 필요하다. 이 정보를 담아두는 테이블을 페이지 테이블이라고 한다. 

페이지 테이블 엔트리는 대상 물리 페이지의 시작 주소(Base Address)와 함께 유효성(Present), 권한(R/W/X), 수정 여부(Dirty) 등 메모리 보호와 관리를 위한 다양한 속성 비트를 포함한다.

### Multi-level Paging
현대 시스템에서는 다양한 페이지 크기를 지원하지만, 가장 기본이 되는 크기는 4KB이다. 이를 기준으로 32비트 시스템(4GB 가상 주소 공간)을 가정하면, 총 1MB개의 페이지 엔트리가 존재할 수 있다. 이때 엔트리 하나가 4바이트라면, 페이지 테이블 전체 크기는 4MB가 된다.

모든 프로세스는 독립적인 가상 주소 공간을 가지므로 프로세스당 페이지 테이블이 필요하다. 하지만 모든 프로세스가 가상 주소 공간 전체를 사용하는 것이 아니므로 4MB를 통째로 할당하는 것은 메모리 낭비이며, 이를 연속된 메모리 공간에 할당해야 한다는 제약 또한 시스템에 큰 부담이 된다.

이 문제를 해결하기 위해 2단계 페이징 기법을 사용한다. 이 방식은 페이지 디렉토리와 페이지 테이블의 두 계층으로 구성된다.

* **페이지 디렉토리(Page Directory)**: 각 4바이트 크기의 엔트리 1,024개로 이루어져 있으며, 각 엔트리는 대응되는 페이지 테이블의 물리 메모리 시작 주소를 가리킨다.
* **페이지 테이블(Page Table)**: 동일하게 각 4바이트 크기의 엔트리 1,024개를 가지며, 각 엔트리는 실제 물리 페이지의 시작 주소를 저장한다.

이와 같은 계층적 구조를 통해 실제로 사용되지 않는 가상 주소 영역에 대해서는 하위 페이지 테이블을 생성하지 않음으로써 메모리를 절약할 수 있다. 결과적으로 다단계 페이징은 하나의 거대한 테이블을 페이지 단위로 쪼개어 관리하므로, 테이블 또한 물리 메모리에 비연속적으로 할당할 수 있다.

### Page Walk
가상 주소는 단순한 메모리 위치가 아니라, 페이지 디렉토리와 테이블의 어떤 엔트리를 참조해야 하는지에 대한 정보를 담고 있다. MMU는 32비트 가상 주소를 다음과 같이 세 부분으로 해석하여 주소를 변환한다.

$$\text{Virtual Address} = \text{Directory Index (10 bits)} + \text{Table Index (10 bits)} + \text{Offset (12 bits)}$$



1. **페이지 디렉토리 접근**: 커널이 CR3 레지스터에 저장해둔 페이지 디렉토리의 물리 주소를 통해 디렉토리에 접근한다.
2. **디렉토리 인덱싱**: 상위 10비트로 페이지 디렉토리에서 대응되는 엔트리를 찾아, 페이지 테이블의 시작 주소를 얻는다.
3. **페이지 테이블 인덱싱**: 중간 10비트로 페이지 테이블에서 엔트리를 찾아, 실제 물리 페이지의 시작 주소를 얻는다.
4. **최종 주소 계산**: 하위 12비트(Offset)를 물리 페이지 시작 주소에 더해 실제 데이터에 접근한다.

이처럼 MMU가 페이지 테이블을 탐색하며 물리 주소를 찾아내는 전체 과정을 페이지 워크라고 한다.



## Memory Protection
페이징 기법은 주소 변환 단계에서 각 메모리 영역에 대한 접근 권한을 검사하여 시스템의 안정성과 보안을 보장한다.

* **Process Isolation**: 모든 프로세스는 자신만의 독립적인 페이지 테이블을 가진다. MMU는 현재 프로세스의 페이지 테이블에 등록된 물리 주소만 참조하므로, 프로세스가 가상 주소를 통해 다른 프로세스의 메모리 영역에 침범하는 것은 구조적으로 불가능하다.
* **Access Control**: 페이지 테이블 엔트리에 포함된 속성 비트를 통해 세밀한 권한 제어를 수행한다. 예를 들어 읽기 전용 영역에 쓰기를 시도하거나, 유저 모드에서 커널 영역 접근을 시도할 경우 MMU가 이를 차단하고 예외(Page Fault)를 발생시킨다.


## PAE (Physical Address Extension)
---
32비트 시스템은 최대 4GB의 주소 대역까지 접근할 수 있다. 하지만 기술의 발전으로 4GB보다 큰 RAM이 필요해졌고, 이에 따라 최대 64GB까지 접근할 수 있게 해주는 기술인 PAE가 도입되었다.

* **Entry Structure Change:** 4GB 이상의 물리 주소를 가리키기 위해 엔트리 크기를 8바이트로 늘렸다. 이를 통해 엔트리 내부에 물리 시작 주소를 담는 비트를 확장하여 더 높은 주소 대역을 지정할 수 있게 했다.
* **3-Level Paging:** 엔트리가 커지면서 4KB 페이지 하나에 512개의 엔트리만 담기게 되었다. 이로 인해 인덱스가 9비트로 제한되었고, 전체 32비트 주소 처리를 위해 최상위에 2비트 계층이 추가된 3단계 페이징(2-9-9-12) 구조를 사용한다.

PAE는 접근할 수 있는 물리 메모리의 범위를 64GB까지 넓혀주는 기술일 뿐, 가상 주소 공간의 크기를 4GB 이상으로 키워주는 것은 아니다.

## PSE (Page Size Extension)
---
기본 페이지 크기인 4KB 대신 더 큰 페이지를 사용하는 기술이다.

* **Huge Page (4MB)**: 2단계 페이징 환경에서 PSE를 사용하면, 페이지 디렉토리 엔트리가 페이지 테이블을 건너뛰고 직접 4MB 크기의 물리 페이지를 가리킨다.
* **PAE와 PSE (2MB)**: PAE가 적용되면 페이지 디렉터리 엔트리가 8바이트가 되고, 한 디렉터리에 512개 엔트리가 들어가므로 대형 페이지 크기가 4MB에서 2MB로 줄어든다.
* **Trade-off**
    * **장점**: 페이지 워크 단계가 줄어들어 주소 변환이 빨라진다. 또한, TLB 엔트리 하나가 커버하는 범위가 훨씬 넓어져 TLB 히트율이 크게 상승한다.
    * **단점**: 내부 단편화가 심해져 메모리 낭비가 발생할 수 있다. 이 때문에 일반적인 프로세스보다는 데이터베이스처럼 대용량 메모리를 점유하는 프로그램에서 선택적으로 사용한다.

## 64-bit Paging
---
현대 64비트 시스템은 보통 48비트 가상 주소 공간을 사용하며 이를 관리하기 위해 4단계 페이징 구조를 채택하고 있다.

* **Hierarchical Structure:** PML4, PDPT, PD, PT의 4단계 계층으로 구성된다. 각 단계는 9비트 인덱스를 사용하며 여기에 하위 12비트 오프셋이 더해져 총 48비트 가상 주소를 처리한다.
* **Canonical Address:** 64비트 주소 중 실제로는 하위 48비트만 사용하며 상위 비트들은 부호 확장과 유사하게 47번째 비트의 값으로 채워져야 한다는 규칙이 존재한다.


## TLB (Translation Lookaside Buffer)
---
페이지 워크는 메모리 접근을 여러 번 수반하므로 성능 병목이 된다. 이를 해결하기 위해 주소 변환 전용 캐시인 TLB를 사용한다.

* **TLB Hit:** MMU가 TLB에서 매핑 정보를 즉시 찾으면 메모리 접근 없이 바로 주소를 변환한다.
* **TLB Miss:** TLB에 정보가 없을 때만 실제 페이지 워크를 수행한다.
* **Fast Page Walk:** 만약 페이지 테이블 정보가 CPU 캐시에 이미 올라와 있다면, 메인 메모리까지 가지 않고도 빠른 주소 변환이 가능하다.

* **TLB Entry Structure**
    * **VPN (Virtual Page Number):** 가상 주소의 페이지 번호. 검색의 key 역할을 한다.
    * **PPN (Physical Page Number):** 매핑된 실제 물리 페이지의 시작 주소.
    * **Attribute Bits:** 해당 페이지의 권한(R/W/X), 유효성(Valid), Dirty 비트 등 보호와 상태 정보를 포함한다.
    * **PCID (Process-Context Identifier):** 프로세스별로 태그를 붙여, 문맥 교환 시 TLB를 매번 비우지 않아도 되게 한다.