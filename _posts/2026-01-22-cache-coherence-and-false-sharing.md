---
title: "Cache Coherence & False Sharing"
date: 2026-01-22 22:00:00 +0900
categories: [CS]
tags: [cache, mesi, false-sharing]
math: true
---

## Why Cache Coherence?
---
현대 시스템은 성능을 위해 Write-back 쓰기 정책을 주로 사용한다. 이 방식은 캐시의 데이터가 수정되어도 즉시 메모리에 반영하지 않으므로, 특정 시점에 캐시와 메모리의 데이터가 서로 다를 수 있다.

멀티 코어 환경에서는 각 코어가 자신만의 L1, L2 캐시를 가진다. 만약 코어 A가 데이터를 수정했는데 코어 B가 메모리나 자신의 캐시에서 옛날 데이터를 읽어간다면 데이터 불일치 문제가 발생한다. 이를 방지하기 위해 각 코어의 캐시라인을 동기화하는 캐시 일관성 메커니즘이 필요하다.

## Coherence Strategies
---
캐시 일관성을 유지하기 위한 하드웨어적 설계 방식은 크게 두 가지로 나뉜다.

### 1. Snooping
모든 코어가 하나의 공유 버스에 연결되어 있는 구조다.
* **작동:** 각 코어의 캐시 컨트롤러는 버스를 항상 감시한다. 다른 코어가 데이터를 요청하거나 상태를 변경하는 메시지를 버스에 던지면(Broadcast), 이를 가로채서 자신의 캐시 상태를 업데이트한다. 
* **특징:** 설계가 비교적 간단하지만, 코어 수가 많아지면 버스에 트래픽이 몰려 성능이 급격히 저하된다. 즉, 확장성이 떨어진다.

### 2. Directory-based
캐시 라인의 상태 정보를 별도의 중앙 관리자(Directory)에 기록하는 방식이다.
* **작동:** 데이터를 변경하거나 요청하려는 코어는 먼저 디렉토리에 알린다. 디렉토리는 해당 데이터를 공유하고 있는 코어들에게만 핀포인트로 메시지를 보낸다(Unicast/Multicast). 
* **장점:** 불필요한 브로드캐스트가 없어 코어가 수백 개 이상인 대규모 시스템에서도 잘 작동한다.
* **단점:** 디렉토리 정보를 저장할 별도의 메모리가 필요하고, 매번 관리자를 거쳐야 하므로 통신 단계가 많아져 레이턴시가 발생한다.

## MESI Protocol
---
스누핑 기반 시스템에서 가장 널리 쓰이는 일관성 프로토콜이다. 캐시라인의 상태를 4가지로 정의한다.

* **M (Modified):** 데이터가 수정된 상태. 나만 들고 있으며 메인 메모리와 데이터가 다르다.
* **E (Exclusive):** 나만 들고 있는 상태. 메인 메모리와 데이터가 일치한다.
* **S (Shared):** 다른 코어도 복사본을 들고 있는 상태. 메인 메모리와 데이터가 일치한다.
* **I (Invalid):** 유효하지 않은 데이터. 쓰레기 값이다. 다시 읽어와야 한다.


### Bus Transactions
MESI 상태 전이를 유도하는 주요 버스 트랜잭션은 다음과 같다.

* **BusRd (Bus Read):** 캐시라인에 데이터가 없을 때 데이터를 읽기 위해 요청하는 신호. 다른 코어가 데이터를 가지고 있지 않으면 메모리에서 가져와 E 상태가 되고, 누군가 이미 가지고 있다면 데이터를 공유받아 S 상태가 된다.
* **BusRdX (Bus Read Exclusive):** 캐시라인에 데이터가 없을 때 데이터를 수정하기 위해 발생하는 신호. 캐시라인의 나머지 데이터를 보존해야 하므로 기존 데이터를 가져옴과 동시에 타 코어의 캐시를 무효화(I)하며 자신은 즉시 M 상태가 된다.
* **BusUpgr (Bus Upgrade):** 캐시라인에 데이터가 있고 공유(S) 상태일 때 데이터를 수정하기 위해 발생하는 신호. 데이터 전송 과정 없이 다른 코어들의 캐시만 무효화(I)하여 수정 권한을 획득하고 M 상태가 된다. (단, E 상태일 때는 이미 나만 데이터를 보유한 상태이므로 버스 신호 없이 즉시 M으로 전이한다.)
* **Flush:** M 상태의 코어가 데이터를 버스에 실어 보내는 신호. 메인 메모리를 최신본으로 업데이트함과 동시에 데이터를 요청한 다른 코어에게 전달하며, 이후 자신의 상태는 S로 전이된다.

## False Sharing
---
멀티 스레드 프로그램에서 서로 다른 두 변수가 우연히 같은 캐시라인에 배치되어 성능이 저하되는 현상이다.

### Causes
두 스레드가 각각 독립적인 변수 A와 B를 수정한다고 가정한다. 두 변수가 같은 캐시라인에 묶여 있다면, MESI 프로토콜에 의해 Cache Ping-pong이라 불리는 다음과 같은 비효율이 발생한다.

1. 스레드 1이 변수 A를 수정하면 캐시라인이 M 상태가 된다.
2. 이때 스레드 2가 변수 B를 수정하려면, 스레드 1의 캐시라인을 무효화하고 데이터를 가져와야 한다.
3. 스레드 1이 다시 A를 쓰려면 또 스레드 2의 캐시를 무효화해야 한다.

실제로는 데이터가 충돌하지 않음에도 불구하고, 캐시라인 단위로 일관성을 관리하기 때문에 마치 하나의 데이터를 두고 싸우는 것처럼 불필요한 트래픽 발생과 메모리 쓰기가 반복된다. 

### Solutions
두 변수가 서로 다른 캐시라인에 놓이도록 강제한다. GCC/Clang 환경에서는 `__attribute__((aligned(64)))` 지시어를 사용하여 변수의 시작 주소를 캐시라인 크기(64B)에 맞춘다.