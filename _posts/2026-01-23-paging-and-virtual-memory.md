---
title: "Paging & Virtual Memory"
date: 2026-01-24 01:00:00 +0900
categories: [CS]
tags: [paging, mmu, tlb, virtual-memory]
math: true
---

## What is Paging?
---
페이징은 물리 메모리를 동일한 크기의 여러 페이지로 나누고, 나뉜 페이지들을 비연속적으로 할당하는 메모리 관리 기법이다. 여기서 비연속적이란 하나의 프로그램이 물리 메모리의 여러 부분에 흩어져 할당될 수 있음을 뜻한다.

물리 메모리가 동일한 크기의 페이지로 나뉘기 때문에 외부 단편화가 발생하지 않는다. 다만, 프로그램에 할당된 메모리가 항상 페이지 크기의 배수인 것은 아니므로 마지막 페이지의 일부가 낭비될 수 있다. 이를 내부 단편화라고 하며, 보통 페이지 크기의 절반 정도가 낭비된다고 본다.

외부 단편화는 메모리 할당 패턴에 따라 예측이 어렵지만, 내부 단편화는 페이지 크기에 따라 그 범위를 충분히 예측할 수 있어 관리가 용이하다는 장점이 있다.


## MMU (Memory Management Unit)
---
모든 프로세스는 독립적인 가상 주소 공간을 갖는다. 프로세스가 포인터로 접근하는 주소는 실제 물리 주소가 아니라 가상 주소이며, 프로세스는 이 공간을 0번지부터 차례대로 나열된 선형적인 형태로 인식하여 사용한다. 이 가상 주소는 커널에 의해 물리 메모리의 특정 위치에 매핑된다.

그러나 페이징은 비연속적인 메모리 할당 기법이므로, 프로세스가 바라보는 가상 주소 공간과 달리 실제 물리 메모리는 연속적으로 배치되지 않는다. 따라서 프로세스가 선형적으로 접근하는 가상 주소를 실제 데이터가 저장된 비연속적인 물리 주소로 변환하는 메커니즘이 필요하며, 이러한 주소 변환을 수행하는 전용 하드웨어를 MMU라고 한다.

## Address Translation Mechanism
---
가상 주소를 물리 주소로 변환하기 위해서는 두 주소의 매핑 정보가 필요하다. 이 정보를 담아두는 테이블을 페이지 테이블이라고 한다. 

페이지 테이블 엔트리(PTE)는 대상 물리 페이지의 기준 주소(Base Address)와 함께 유효성(Present), 권한(R/W/X), 수정 여부(Dirty) 등 메모리 보호와 관리를 위한 다양한 속성 비트를 포함한다.

### Multi-level Paging
현대 시스템에서는 다양한 페이지 크기를 지원하지만, 가장 기본이 되는 크기는 4KB이다. 이를 기준으로 32비트 시스템(4GB 가상 주소 공간)을 가정하면, 총 1MB개의 엔트리가 존재할 수 있다. 이때 엔트리 하나가 4바이트라면, 페이지 테이블 전체 크기는 4MB가 된다.

모든 프로세스는 독립적인 가상 주소 공간을 가지므로 프로세스당 페이지 테이블이 필요하다. 하지만 모든 프로세스가 가상 주소 공간 전체를 사용하는 것이 아니므로 4MB를 통째로 할당하는 것은 메모리 낭비이며, 이를 연속된 메모리 공간에 할당해야 한다는 제약 또한 시스템에 큰 부담이 된다.

이 문제를 해결하기 위해 2단계 페이징 기법을 사용한다. 이 방식은 페이지 디렉토리와 페이지 테이블의 두 계층으로 구성된다.

* **Page Directory**: 각 4바이트 크기의 엔트리 1,024개로 이루어져 있으며, 각 엔트리는 대응되는 페이지 테이블의 기준 주소를 가리킨다.
* **Page Table**: 동일하게 각 4바이트 크기의 엔트리 1,024개를 가지며, 각 엔트리는 실제 물리 페이지의 기준 주소를 저장한다.

이와 같은 계층적 구조를 통해 실제로 사용되지 않는 가상 주소 영역에 대해서는 하위 페이지 테이블을 생성하지 않음으로써 메모리를 절약할 수 있다. 결과적으로 다단계 페이징은 하나의 거대한 테이블을 페이지 단위로 쪼개어 관리하므로, 테이블 또한 물리 메모리에 비연속적으로 할당할 수 있다.

### Page Walk
가상 주소는 단순한 메모리 위치가 아니라, 페이지 디렉토리와 테이블의 어떤 엔트리를 참조해야 하는지에 대한 정보를 담고 있다. MMU는 32비트 가상 주소를 다음과 같이 세 부분으로 해석하여 주소를 변환한다.

$$\text{Virtual Address} = \text{Directory Index (10 bits)} + \text{Table Index (10 bits)} + \text{Offset (12 bits)}$$



1. **페이지 디렉토리 접근**: 커널이 CR3 레지스터에 저장해둔 페이지 디렉토리의 기준 주소를 통해 디렉토리에 접근한다.
2. **디렉토리 인덱싱**: 상위 10비트로 페이지 디렉토리에서 대응되는 엔트리를 찾아, 페이지 테이블의 기준 주소를 얻는다.
3. **페이지 테이블 인덱싱**: 중간 10비트로 페이지 테이블에서 엔트리를 찾아, 실제 물리 페이지의 기준 주소를 얻는다.
4. **최종 주소 계산**: 하위 12비트(Offset)를 물리 페이지 기준 주소에 더해 실제 데이터에 접근한다.

이처럼 MMU가 페이지 테이블을 탐색하며 물리 주소를 찾아내는 전체 과정을 페이지 워크라고 한다.

## Memory Protection
---
페이징 기법은 주소 변환 단계에서 각 메모리 영역에 대한 접근 권한을 검사하여 시스템의 안정성과 보안을 보장한다.

* **Process Isolation**: 모든 프로세스는 자신만의 독립적인 페이지 테이블을 가진다. MMU는 현재 프로세스의 페이지 테이블에 등록된 기준 주소만 참조하므로, 프로세스가 가상 주소를 통해 다른 프로세스의 메모리 영역에 침범하는 것은 구조적으로 불가능하다.
* **Access Control**: PDE, PTE에 포함된 속성 비트를 통해 세밀한 권한 제어를 수행한다. 예를 들어 읽기 전용 영역에 쓰기를 시도하거나, 유저 모드에서 커널 영역 접근을 시도할 경우 MMU가 이를 차단하고 예외(Page Fault)를 발생시킨다.

## TLB (Translation Lookaside Buffer)
---
페이지 워크는 메모리 접근을 여러 번 수반하므로 성능 병목이 된다. 이를 해결하기 위해 주소 변환 전용 캐시인 TLB를 사용한다.

* **TLB Hit:** MMU가 TLB에서 매핑 정보를 즉시 찾으면 메모리 접근 없이 바로 주소를 변환한다.
* **TLB Miss:** TLB에 정보가 없을 때만 실제 페이지 워크를 수행한다.
* **Fast Page Walk:** 만약 페이지 테이블 정보가 CPU 캐시에 이미 올라와 있다면, 메인 메모리까지 가지 않고도 빠른 주소 변환이 가능하다.

* **TLB Entry Structure**
    * **VPN (Virtual Page Number):** 가상 주소의 페이지 번호. 검색의 key 역할을 한다.
    * **PPN (Physical Page Number):** 매핑된 실제 물리 페이지의 기준 주소.
    * **Attribute Bits:** 해당 페이지의 권한(R/W/X), 유효성(Valid), Dirty 비트 등 보호와 상태 정보를 포함한다.
    * **PCID (Process-Context Identifier):** 프로세스별로 태그를 붙여, 문맥 교환 시 TLB를 매번 비우지 않아도 되게 한다.

## PAE (Physical Address Extension)
---
32비트 시스템은 최대 4GB의 주소 대역까지 접근할 수 있다. 하지만 기술의 발전으로 4GB보다 큰 RAM이 필요해졌고, 이에 따라 최대 64GB까지 접근할 수 있게 해주는 기술인 PAE가 도입되었다.

* **Entry Structure Change:** 4GB 이상의 물리 주소를 가리키기 위해 엔트리 크기를 8바이트로 늘렸다. 이를 통해 엔트리 내부에 기준 주소를 담는 비트를 확장하여 더 높은 주소 대역을 지정할 수 있게 했다.
* **3-Level Paging:** 엔트리가 커지면서 4KB 페이지 하나에 512개의 엔트리만 담기게 되었다. 이로 인해 인덱스가 9비트로 제한되었고, 전체 32비트 주소 처리를 위해 최상위에 2비트 계층이 추가된 3단계 페이징(2-9-9-12) 구조를 사용한다.

PAE는 접근할 수 있는 물리 메모리의 범위를 64GB까지 넓혀주는 기술일 뿐, 가상 주소 공간의 크기를 4GB 이상으로 키워주는 것은 아니다.

## PSE (Page Size Extension)
---
기본 페이지 크기인 4KB 대신 더 큰 페이지를 사용하는 기술이다.

* **Huge Page (4MB)**: 2단계 페이징 환경에서 PSE를 사용하면, 페이지 디렉토리 엔트리가 페이지 테이블을 건너뛰고 직접 4MB 크기의 물리 페이지를 가리킨다.
* **PAE와 PSE (2MB)**: PAE가 적용되면 페이지 디렉터리 엔트리가 8바이트가 되고, 한 디렉터리에 512개 엔트리가 들어가므로 대형 페이지 크기가 4MB에서 2MB로 줄어든다.
* **Trade-off**
    * **장점**
        * 페이지 워크 단계가 줄어들어 주소 변환이 빨라진다.
        * TLB 엔트리 하나가 커버하는 범위가 훨씬 넓어져 TLB 히트율이 크게 상승한다.
        * 더 큰 단위로 메모리를 관리하므로 커널이 추적해야 할 페이지 메타데이터 수가 대폭 감소한다.
        * 페이지 폴트 발생 빈도가 줄어든다. 동일한 메모리 영역을 4KB 단위로 접근하면 1024번의 페이지 폴트가 발생할 수 있지만, 4MB 페이지는 단 한 번만 발생한다.
    * **단점** 
        * 내부 단편화가 심해져 메모리 낭비가 발생할 수 있다.
        * HDD 환경에서 스왑 시 성능 저하 위험이 있다. 4KB 페이지는 파일시스템 블록 크기와 일치하여 디스크 섹터상 인접 배치되지만, 4MB 페이지는 1024개의 블록이 필요하므로 단편화 발생 시 탐색/회전 지연이 급증할 수 있다.
        * 이 때문에 스왑이 발생하지 않는 커널 공간이나, 메모리를 충분히 확보하여 스왑을 최소화하는 데이터베이스 같은 프로그램에서 주로 사용한다.

## 64-bit Paging
---
현대 64비트 시스템은 보통 48비트 가상 주소 공간을 사용하며 이를 관리하기 위해 4단계 페이징 구조를 채택하고 있다.

* **Hierarchical Structure:** PML4, PDPT, PD, PT의 4단계 계층으로 구성된다. 각 단계는 9비트 인덱스를 사용하며 여기에 하위 12비트 오프셋이 더해져 총 48비트 가상 주소를 처리한다.
* **Canonical Address:** 64비트 주소 중 실제로는 하위 48비트만 사용하며 상위 비트들은 부호 확장과 유사하게 47번째 비트의 값으로 채워져야 한다는 규칙이 존재한다.


## Virtual Memory 
---
물리 메모리(RAM)의 크기 한계를 극복하기 위해 디스크 공간을 메모리처럼 활용하는 기술이다. 커널은 현재 사용 중인 물리 페이지의 내용을 디스크의 특정 영역에 임시로 내보냈다가 필요할 때 다시 불러올 수 있으며, 이러한 용도로 사용되는 디스크 공간을 스왑 영역(Swap Area)이라 한다. 이를 통해 시스템은 가상 주소 공간 전체를 물리 메모리 크기와 무관하게 활용할 수 있다.

### Demand Paging
프로그램의 모든 코드와 데이터가 항상 사용되는 것은 아니다. 예외 처리 코드와 같은 일부 영역은 실행 중 한 번도 접근되지 않을 수 있다.

요구 페이징은 프로그램 적재 시 전체를 한 번에 메모리에 올리지 않고, 실제로 접근이 발생한 페이지만 물리 메모리에 매핑하는 기법이다. 초기에는 가상 주소 공간과 페이지 테이블 엔트리만 생성하되, Present 비트는 비활성화하고 물리 메모리는 할당하지 않는다.

##### File-backed page

실행 파일의 코드나 데이터 영역처럼 디스크 파일에 원본이 존재하는 경우, PTE에는 기준 주소 대신 파일 내 오프셋 정보가 저장된다. 이 페이지에 접근하면 페이지 폴트가 발생하고, 커널은 해당 파일 위치에서 내용을 읽어와 물리 페이지를 할당한 뒤 페이지 테이블을 갱신한다.

##### Anonymous page 

힙이나 스택처럼 파일 기반이 아닌 익명 메모리 영역은 PTE만 생성되고 초기에는 아무 내용도 없는 상태다. 첫 접근 시 페이지 폴트가 발생하면 커널은 0으로 채운 물리 페이지를 할당한다. 이후 해당 페이지가 스왑 아웃되면 스왑 영역의 블록 번호가 PTE에 기록된다.

두 경우 모두 페이지 폴트 핸들러가 필요한 데이터를 메모리로 가져오고 매핑을 완료한 뒤, 예외가 발생한 명령어부터 실행을 재개한다.

### Page Replacement
물리 메모리가 부족한 상황에서 페이지 폴트가 발생하면, 커널은 기존 물리 페이지를 디스크로 내보내 공간을 확보해야 한다. 이를 스왑 아웃(Swap-out)이라 한다.

스왑 아웃 대상 페이지의 내용이 수정되었다면(Dirty 비트 확인) 스왑 영역에 기록하고, 그렇지 않으면 단순히 버린다. PTE의 Present 비트는 비활성화되고, 기준 주소 필드에는 스왑 영역의 블록 번호가 저장된다. 해당 물리 페이지는 재사용 가능 상태가 된다.

이후 스왑 아웃된 페이지에 다시 접근하면 페이지 폴트가 발생한다. 커널은 PTE에 저장된 블록 번호를 통해 스왑 영역에서 내용을 읽어와 새로운 물리 페이지에 복원하고 매핑을 갱신한다. 디스크 I/O는 DMA와 인터럽트를 통해 처리되며, 완료될 때까지 프로세스는 차단된다.

### Replacement Algorithm

#### 1. LRU (Least Recently Used)
시간 지역성에 근거하여 가장 오랫동안 사용되지 않은 페이지를 교체한다. 이론적으로는 최적에 가깝지만 구현 비용이 크다.

#### 2. Second Chance Algorithm
LRU의 효율적인 근사 알고리즘이다.

**동작 방식**
- 하드웨어는 페이지 접근 시마다 PTE의 액세스 비트를 1로 설정한다
- 커널은 교체가 필요할 때 물리 페이지 메타데이터 리스트를 순회한다
- 각 메타데이터의 역방향 매핑 정보로 해당 PTE에 접근한다

**교체 결정**
- 비트가 1: 최근 참조되었으므로 0으로 재설정하고 기회를 한 번 더 준다
- 비트가 0: 이전 순회 이후 재참조되지 않았으므로 즉시 교체한다

완벽하게 가장 오래된 페이지를 찾지는 못하지만, 최근 사용된 페이지는 확실히 보존한다.


## Thrashing
---
다중 프로그래밍 정도(Degree of Multiprogramming)가 지나치게 높아지면 각 프로세스에 할당되는 메모리가 부족해진다. 페이지 교체가 빈번해지고 디스크 I/O가 급증하면서 프로세스들이 차단 상태에 머물게 된다. 결과적으로 CPU 이용률이 급격히 저하되는 현상을 쓰래싱이라 한다.

### Working Set
프로세스는 지역성 원리에 따라 특정 시점에 집중적으로 참조하는 페이지 집합을 가진다. 이를 작업 집합이라 한다. 쓰래싱을 막으려면 각 프로세스의 작업 집합만큼 프레임을 보장해야 한다.

#### Traditional Approach
시간(Δ)을 기준으로 작업 집합을 정의한다. 각 페이지마다 히스토리 비트를 둔다.

* 타이머 인터럽트마다 모든 페이지의 액세스 비트를 확인한다.
* 액세스 비트가 1이면 히스토리 비트 맨 앞에 1을 넣고 나머지를 오른쪽으로 시프트한다.
* 히스토리 비트가 0이 아니면 최근 시간 윈도우 내에 사용된 페이지로 간주한다.
* 매번 모든 페이지를 스캔해야 해서 오버헤드가 크다.

#### Heuristic Approach
실제 시스템은 프로세스별 작업집합을 개별 관리하지 않고, Active/Inactive 리스트를 통해 시스템 전체의 할당된 페이지를 통합으로 관리한다. 시간 대신 거리(Distance)를 측정한다.

* **Initial Placement**: 새로 할당된 페이지는 Inactive 리스트 헤드에 삽입된다.
* **Refault Distance**: 페이지가 방출된 후 다시 폴트가 발생할 때까지 시스템에서 방출된 전체 페이지 수를 의미한다. shadow entry 등으로 추적한다. 예를 들어 페이지 A 방출 → B, C, D, E, F 방출 → 페이지 A 폴트 발생 시 Refault Distance는 5다. 이 거리가 짧을수록 재사용 주기가 빠르다는 의미다.
* **Promotion**: `Refault Distance < Active size`라면 해당 페이지를 즉시 Active 리스트 헤드로 승격시킨다.
* **Eviction and Activation**: 메모리 부족 시 Inactive 리스트 꼬리부터 스캔한다. 액세스 비트가 1인 페이지는 Active 리스트 헤드로 승격시키고, 0인 페이지는 회수한다.
* **List Balancing**: Active 리스트와 Inactive 리스트 간 크기 균형을 유지하기 위해, Active 리스트 꼬리를 주기적으로 스캔하여 액세스 비트가 0인 페이지를 Inactive로 이동시킨다.

#### Process Suspension
모든 프로세스의 작업 집합 크기 합(∑WSS)이 가용 메모리를 초과하면 개별 페이지 교체로는 쓰래싱을 막을 수 없다. 이때 커널은 특정 프로세스를 통째로 스왑 아웃시킨다. 확보된 메모리를 남은 프로세스들에게 몰아줘서 최소한 실행 중인 프로세스들이 정상적으로 작업 집합을 유지하게 한다.